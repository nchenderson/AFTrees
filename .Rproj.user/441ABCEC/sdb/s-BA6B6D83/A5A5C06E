{
    "collab_server" : "",
    "contents" : "\n\nlibrary(AFTrees)\nlibrary(survival)\nlibrary(pracma)\n\nsource(\"~/personalized/Reproduce_folders/SimulationCode/friedman/friedman_def.R\")\n\nform_naive <- Surv(yy, status) ~ trt\nform_aft <- Surv(yy,status) ~ trt*(x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20)\n\nn <- 200\nnvars <- 20\n\n#set.seed(417)\nnreps <- 50\nnskip <- 500*4\nndpost <- 1000*5\nnskip <- 1000\nndpost <- 500\nnumn <- 1\nRMSE <- MissClass <- MissClassNaive <- Coverage <- obs_frac <- rep(0, nreps)\nRMSE_SP <- MissClass_SP <- Coverage_SP <- obs_frac_SP <- rep(0, nreps)\nRMSE_NPS <- MissClass_NPS <- Coverage_NPS <- obs_frac_NPS <- rep(0, nreps)\nRMSE_AFT <- Coverage_AFT <- MissClass_AFT <- rep(0, nreps)\nResultsNaive <- rep(0, numn*3)\nResults_NP <- Results_NPS <- matrix(0, nrow=numn*3, ncol=7)\nResults_AFT <- Results_SP <- matrix(0, nrow=numn*3, ncol=5)\ncolnames(Results_NP) <- c(\"RMSE\",\"MissClass\",\"coverage\", \"n\",\"obs_frac\")\ncolnames(Results_SP) <- c(\"RMSE\",\"MissClass\",\"coverage\", \"n\",\"obs_frac\")\ncolnames(Results_AFT) <- c(\"RMSE\",\"MissClass\",\"coverage\", \"n\",\"obs_frac\")\ncount <- 1\nsig <- .025\n\nXX <- matrix(rnorm(nvars*n), nrow=n, ncol=nvars)\nTrt <- sample(c(0,1), size=n, replace=TRUE)\nXmat <- cbind(Trt, XX)\nXmat_alt <- cbind(1 - Trt, XX)\n\ntheta.np <- theta.nps <- matrix(0.0, nrow=nreps, ncol=n)\n\nfor(k in 1:nreps) {\n\n  colnames(Xmat) <- colnames(Xmat_alt) <- c(\"trt\",\"x1\",\"x2\",\"x3\",\"x4\",\"x5\",\"x6\",\"x7\",\"x8\",\"x9\",\"x10\",\"x11\",\"x12\",\"x13\",\"x14\",\"x15\",\"x16\",\"x17\",\"x18\",\"x19\",\"x20\")\n  #colnames(Xmat) <- c(\"trt\",\"x1\",\"x2\",\"x3\",\"x4\",\"x5\",\"x6\",\"x7\",\"x8\",\"x9\",\"x10\")\n  obj0 <- GenerateFriedmanVals(nvars, unif_low=-1, unif_up=1)\n  obj1 <- GenFriedmanValsTrt(nvars, unif_low=-.2, unif_up=.3)\n  generated_fn <- Frand(XX, Trt, obj0, obj1)\n\n  log_yy <- generated_fn$ff + sig*rnorm(n)\n  yy <- exp(log_yy)\n  status <- rep(1,n)\n  SimDat <- data.frame(yy, status, Xmat)\n  SimDatAlt <- data.frame(yy, status, Xmat_alt)\n\n  TrueTheta <- generated_fn$TrueTheta\n  harmful <- ifelse(TrueTheta < 0, 1, 0)\n  beneficial <- 1 - harmful\n\n  Xaft <- model.matrix(form_aft, SimDat)\n  Xaft_alt <- model.matrix(form_aft, SimDatAlt)\n  VV <- Xaft - Xaft_alt\n\n  ##################################################################\n  ### AFT model fit and others\n  aftlm <- survreg(form_aft, dist=\"lognormal\", data=SimDat)\n  aft_hat <- log(predict(aftlm))\n  aft_hat_alt <- log(predict(aftlm, newdata=SimDatAlt))\n  aft_predict <- aft_lower <- aft_upper <- aft_assign <- rep(0.0, n)\n  var_cov <- aftlm$var[-length(diag(aftlm$var)),-length(diag(aftlm$var))]\n  aft_var <- rep(0.0, n)\n  for(j in 1:n) {\n    aft_var[j] <- sum((var_cov%*%VV[j,])*VV[j,])\n    if(Trt[j]==1) {\n      aft_predict[j] <- aft_hat[j] - aft_hat_alt[j]\n    }\n    else if(Trt[j]==0) {\n      aft_predict[j] <- aft_hat_alt[j] - aft_hat[j]\n    }\n    aft_assign[j] <- ifelse(aft_predict[j] > 0, 1, 0)\n    aft_lower[j] <- aft_predict[j] - qnorm(.975)*sqrt(aft_var[j])\n    aft_upper[j] <- aft_predict[j] + qnorm(.975)*sqrt(aft_var[j])\n  }\n  RMSE_AFT[k] <- sqrt(mean((aft_predict - TrueTheta)^2))\n  Coverage_AFT[k] <- mean((TrueTheta > aft_lower) & (TrueTheta <= aft_upper))\n  MissClass_AFT[k] <- sum(harmful*aft_assign + beneficial*(1 - aft_assign))  ### Number misclassified\n\n  fit_naive <- survreg(form_naive, data=SimDat)\n  if(fit_naive$coefficients[2] > 0) {\n    trt_naive.assign <- rep(1, n)\n  } else if( fit_naive$coefficients[2] <= 0) {\n    trt_naive.assign <- rep(0, n)\n  }\n  #############################################################################\n  #### Non-parametric BART\n  obj <- IndivAFT(x.train=XX,y.train=yy,status=rep(1,n),Trt=Trt, ndpost=ndpost,nskip=nskip,printevery=100, sigquant=.5, keepevery=5)\n  post.means <- colMeans(obj$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob <- apply(obj$Theta, 2, function(x) mean( x > 0))\n  treat.assign <- ifelse(post.prob > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci <- apply(obj$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci <- apply(obj$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass[k] <- sum(harmful*treat.assign + beneficial*(1 - treat.assign))  ### Number misclassified\n  RMSE[k] <- sqrt(mean((post.means - TrueTheta)^2))\n  Coverage[k] <- mean((TrueTheta > lower.ci) & (TrueTheta <= upper.ci))\n  obs_frac[k] <- 1\n  theta.np[k,] <- post.means\n  print(\"hello\")\n  #############################################################################\n  #### Non-parametric BART\n  #Xtmp <- as.matrix(XX[,1:2], nrow=nrow(XX), ncol=2)\n  obj_np <- IndivAFTSeparate(x.train=XX,y.train=yy,status=rep(1,n),Trt=Trt, ndpost=ndpost, nskip=nskip, printevery=100, sigquant=.5, keepevery=5)\n  post.means <- colMeans(obj_np$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob <- apply(obj_np$Theta, 2, function(x) mean( x > 0))\n  treat.assign <- ifelse(post.prob > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci <- apply(obj_np$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci <- apply(obj_np$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass_NPS[k] <- sum(harmful*treat.assign + beneficial*(1 - treat.assign))  ### Number misclassified\n  RMSE_NPS[k] <- sqrt(mean((post.means - TrueTheta)^2))\n  Coverage_NPS[k] <- mean((TrueTheta > lower.ci) & (TrueTheta <= upper.ci))\n  obs_frac_NPS[k] <- 1\n  theta.nps[k,] <- post.means\n\n  #################################################################################\n  ###  Semi-parametric BART and Naive\n  obj_sp <- IndivAFT(x.train=XX,y.train=yy,status=rep(1,n),Trt=Trt, nonparametric=FALSE, ndpost=ndpost,nskip=nskip,printevery=100, sigquant=.9, keepevery=5)\n  overall <- mean(obj$Theta)\n\n  post.means.sp <- colMeans(obj_sp$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob.sp <- apply(obj_sp$Theta, 2, function(x) mean( x > 0))\n  treat.assign.sp <- ifelse(post.prob.sp > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci.sp <- apply(obj_sp$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci.sp <- apply(obj_sp$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass_SP[k] <- sum(harmful*treat.assign.sp + beneficial*(1 - treat.assign.sp))  ### Number misclassified\n  RMSE_SP[k] <- sqrt(mean((post.means.sp - TrueTheta)^2))\n  Coverage_SP[k] <- mean((TrueTheta > lower.ci.sp) & (TrueTheta <= upper.ci.sp))\n  obs_frac_SP[k] <- 1\n\n  MissClassNaive[k] <- sum(harmful*trt_naive.assign + beneficial*(1 - trt_naive.assign))\n  print(c(count,k))\n}\n\nResults_NP[count,1] <- mean(RMSE)\nResults_NP[count,2] <- mean(MissClass)/n\nResults_NP[count,3] <- mean(Coverage)\nResults_NP[count,4] <- n\nResults_NP[count,5] <- mean(obs_frac)\nBias <- colMeans(theta.np) - generated_fn$TrueTheta\nvv <- apply(theta.np, 2, var)\nResults_NP[count,6] <- mean(abs(Bias))\nResults_NP[count,7] <- mean(vv)\n\nResults_NPS[count,1] <- mean(RMSE_NPS)\nResults_NPS[count,2] <- mean(MissClass_NPS)/n\nResults_NPS[count,3] <- mean(Coverage_NPS)\nResults_NPS[count,4] <- n\nResults_NPS[count,5] <- mean(obs_frac_NPS)\nBias2 <- colMeans(theta.nps) - generated_fn$TrueTheta\nvv2 <- apply(theta.nps, 2, var)\nResults_NPS[count,6] <- mean(abs(Bias2))\nResults_NPS[count,7] <- mean(vv2)\n\nResults_SP[count,1] <- mean(RMSE_SP)\nResults_SP[count,2] <- mean(MissClass_SP)/n\nResults_SP[count,3] <- mean(Coverage_SP)\nResults_SP[count,4] <- n\nResults_SP[count,5] <- mean(obs_frac_SP)\n\n\nResults_AFT[count,1] <- mean(RMSE_AFT)\nResults_AFT[count,2] <- mean(MissClass_AFT)/n\nResults_AFT[count,3] <- mean(Coverage_AFT)\nResults_AFT[count,4] <- n\nResults_AFT[count,5] <- mean(obs_frac)\nResultsNaive[count] <- mean(MissClassNaive)/n\n\ncount <- count + 1\n\n\ntheta.np <- theta.nps <- matrix(0.0, nrow=nreps, ncol=n)\nXX <- matrix(rnorm(nvars*n), nrow=n, ncol=nvars)\nTrt <- sample(c(0,1), size=n, replace=TRUE)\nXmat <- cbind(Trt, XX)\nXmat_alt <- cbind(1 - Trt, XX)\n\nfor(k in 1:nreps) {\n\n  colnames(Xmat) <- colnames(Xmat_alt) <- c(\"trt\",\"x1\",\"x2\",\"x3\",\"x4\",\"x5\",\"x6\",\"x7\",\"x8\",\"x9\",\"x10\",\"x11\",\"x12\",\"x13\",\"x14\",\"x15\",\"x16\",\"x17\",\"x18\",\"x19\",\"x20\")\n  obj0 <- GenerateFriedmanVals(nvars)\n  obj1 <- GenFriedmanValsTrt(nvars, unif_low=-.2, unif_up=.3)\n  generated_fn <- Frand(XX, Trt, obj0, obj1)\n\n  log_yy <- generated_fn$ff + sig*rnorm(n)\n  cens_times <- runif(n, min=.2, max=2)\n  delta <- as.numeric(log_yy <= cens_times)\n  log_yy[delta==0] <- cens_times[delta==0]\n  yy <- exp(log_yy)\n  status <- delta\n  SimDat <- data.frame(yy, status, Xmat)\n  SimDatAlt <- data.frame(yy, status, Xmat_alt)\n\n  TrueTheta <- generated_fn$TrueTheta\n  harmful <- ifelse(TrueTheta < 0, 1, 0)\n  beneficial <- 1 - harmful\n\n  Xaft <- model.matrix(form_aft, SimDat)\n  Xaft_alt <- model.matrix(form_aft, SimDatAlt)\n  VV <- Xaft - Xaft_alt\n\n  ##################################################################\n  ### AFT model fit and others\n  aftlm <- survreg(form_aft, dist=\"lognormal\", data=SimDat)\n  aft_hat <- log(predict(aftlm))\n  aft_hat_alt <- log(predict(aftlm, newdata=SimDatAlt))\n  aft_predict <- aft_lower <- aft_upper <- aft_assign <- rep(0.0, n)\n  var_cov <- aftlm$var[-length(diag(aftlm$var)),-length(diag(aftlm$var))]\n  aft_var <- rep(0.0, n)\n  for(j in 1:n) {\n    aft_var[j] <- sum((var_cov%*%VV[j,])*VV[j,])\n    if(Trt[j]==1) {\n      aft_predict[j] <- aft_hat[j] - aft_hat_alt[j]\n    }\n    else if(Trt[j]==0) {\n      aft_predict[j] <- aft_hat_alt[j] - aft_hat[j]\n    }\n    aft_assign[j] <- ifelse(aft_predict[j] > 0, 1, 0)\n    aft_lower[j] <- aft_predict[j] - qnorm(.975)*sqrt(aft_var[j])\n    aft_upper[j] <- aft_predict[j] + qnorm(.975)*sqrt(aft_var[j])\n  }\n  RMSE_AFT[k] <- sqrt(mean((aft_predict - TrueTheta)^2))\n  Coverage_AFT[k] <- mean((TrueTheta > aft_lower) & (TrueTheta <= aft_upper))\n  MissClass_AFT[k] <- sum(harmful*aft_assign + beneficial*(1 - aft_assign))  ### Number misclassified\n\n  fit_naive <- survreg(form_naive, data=SimDat)\n  if(fit_naive$coefficients[2] > 0) {\n    trt_naive.assign <- rep(1, n)\n  }\n  else if( fit_naive$coefficients[2] <= 0) {\n    trt_naive.assign <- rep(0, n)\n  }\n  #############################################################################\n  #### Non-parametric BART\n  obj <- IndivAFT(x.train=XX,y.train=yy,status=delta,Trt=Trt, ndpost=ndpost,nskip=nskip,printevery=100, sigquant=.5, keepevery=5)\n  post.means <- colMeans(obj$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob <- apply(obj$Theta, 2, function(x) mean( x > 0))\n  treat.assign <- ifelse(post.prob > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci <- apply(obj$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci <- apply(obj$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass[k] <- sum(harmful*treat.assign + beneficial*(1 - treat.assign))  ### Number misclassified\n  RMSE[k] <- sqrt(mean((post.means - TrueTheta)^2))\n  Coverage[k] <- mean((TrueTheta > lower.ci) & (TrueTheta <= upper.ci))\n  obs_frac[k] <- mean(delta)\n  theta.np[k,] <- post.means\n\n\n  #############################################################################\n  #### Non-parametric BART\n  #Xtmp <- as.matrix(XX[,1:2], nrow=nrow(XX), ncol=2)\n  obj_np <- IndivAFTSeparate(x.train=XX,y.train=yy,status=rep(1,n),Trt=Trt, ndpost=ndpost, nskip=nskip, printevery=100, sigquant=.5, keepevery=5)\n  post.means <- colMeans(obj_np$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob <- apply(obj_np$Theta, 2, function(x) mean( x > 0))\n  treat.assign <- ifelse(post.prob > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci <- apply(obj_np$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci <- apply(obj_np$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass_NPS[k] <- sum(harmful*treat.assign + beneficial*(1 - treat.assign))  ### Number misclassified\n  RMSE_NPS[k] <- sqrt(mean((post.means - TrueTheta)^2))\n  Coverage_NPS[k] <- mean((TrueTheta > lower.ci) & (TrueTheta <= upper.ci))\n  obs_frac_NPS[k] <- mean(delta)\n  theta.nps[k,] <- post.means\n\n\n  #################################################################################\n  ###  Semi-parametric BART and Naive\n  obj_sp <- IndivAFT(x.train=XX,y.train=yy,status=delta,Trt=Trt, nonparametric=FALSE, ndpost=ndpost,nskip=nskip,printevery=100, sigquant=.9, keepevery=5)\n  overall <- mean(obj$Theta)\n\n  post.means.sp <- colMeans(obj_sp$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob.sp <- apply(obj_sp$Theta, 2, function(x) mean( x > 0))\n  treat.assign.sp <- ifelse(post.prob.sp > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci.sp <- apply(obj_sp$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci.sp <- apply(obj_sp$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass_SP[k] <- sum(harmful*treat.assign.sp + beneficial*(1 - treat.assign.sp))  ### Number misclassified\n  RMSE_SP[k] <- sqrt(mean((post.means.sp - TrueTheta)^2))\n  Coverage_SP[k] <- mean((TrueTheta > lower.ci.sp) & (TrueTheta <= upper.ci.sp))\n  obs_frac_SP[k] <- mean(delta)\n\n  MissClassNaive[k] <- sum(harmful*trt_naive.assign + beneficial*(1 - trt_naive.assign))\n  print(c(count,k))\n}\n\nResults_NP[count,1] <- mean(RMSE)\nResults_NP[count,2] <- mean(MissClass)/n\nResults_NP[count,3] <- mean(Coverage)\nResults_NP[count,4] <- n\nResults_NP[count,5] <- mean(obs_frac)\nBias <- colMeans(theta.np) - generated_fn$TrueTheta\nvv <- apply(theta.np, 2, var)\nResults_NP[count,6] <- mean(abs(Bias))\nResults_NP[count,7] <- mean(vv)\n\nResults_NPS[count,1] <- mean(RMSE_NPS)\nResults_NPS[count,2] <- mean(MissClass_NPS)/n\nResults_NPS[count,3] <- mean(Coverage_NPS)\nResults_NPS[count,4] <- n\nResults_NPS[count,5] <- mean(obs_frac_NPS)\nBias2 <- colMeans(theta.nps) - generated_fn$TrueTheta\nvv2 <- apply(theta.nps, 2, var)\nResults_NPS[count,6] <- mean(abs(Bias2))\nResults_NPS[count,7] <- mean(vv2)\n\n\nResults_SP[count,1] <- mean(RMSE_SP)\nResults_SP[count,2] <- mean(MissClass_SP)/n\nResults_SP[count,3] <- mean(Coverage_SP)\nResults_SP[count,4] <- n\nResults_SP[count,5] <- mean(obs_frac_SP)\n\n\nResults_AFT[count,1] <- mean(RMSE_AFT)\nResults_AFT[count,2] <- mean(MissClass_AFT)/n\nResults_AFT[count,3] <- mean(Coverage_AFT)\nResults_AFT[count,4] <- n\nResults_AFT[count,5] <- mean(obs_frac)\nResultsNaive[count] <- mean(MissClassNaive)/n\n\ncount <- count + 1\n\n\ntheta.np <- theta.nps <- matrix(0.0, nrow=nreps, ncol=n)\nXX <- matrix(rnorm(nvars*n), nrow=n, ncol=nvars)\nTrt <- sample(c(0,1), size=n, replace=TRUE)\nXmat <- cbind(Trt, XX)\nXmat_alt <- cbind(1 - Trt, XX)\n\nfor(k in 1:nreps) {\n\n  colnames(Xmat) <- colnames(Xmat_alt) <- c(\"trt\",\"x1\",\"x2\",\"x3\",\"x4\",\"x5\",\"x6\",\"x7\",\"x8\",\"x9\",\"x10\",\"x11\",\"x12\",\"x13\",\"x14\",\"x15\",\"x16\",\"x17\",\"x18\",\"x19\",\"x20\")\n\n  obj0 <- GenerateFriedmanVals(nvars)\n  obj1 <- GenFriedmanValsTrt(nvars, unif_low=-.2, unif_up=.3)\n  generated_fn <- Frand(XX, Trt, obj0, obj1)\n\n  log_yy <- generated_fn$ff + sig*rnorm(n)\n  cens_times <- runif(n, min=-.8, max=1.5)\n  delta <- as.numeric(log_yy <= cens_times)\n  log_yy[delta==0] <- cens_times[delta==0]\n  yy <- exp(log_yy)\n  status <- delta\n  SimDat <- data.frame(yy, status, Xmat)\n  SimDatAlt <- data.frame(yy, status, Xmat_alt)\n\n  TrueTheta <- generated_fn$TrueTheta\n  harmful <- ifelse(TrueTheta < 0, 1, 0)\n  beneficial <- 1 - harmful\n\n  Xaft <- model.matrix(form_aft, SimDat)\n  Xaft_alt <- model.matrix(form_aft, SimDatAlt)\n  VV <- Xaft - Xaft_alt\n\n  ##################################################################\n  ### AFT model fit and others\n  aftlm <- survreg(form_aft, dist=\"lognormal\", data=SimDat)\n  aft_hat <- log(predict(aftlm))\n  aft_hat_alt <- log(predict(aftlm, newdata=SimDatAlt))\n  aft_predict <- aft_lower <- aft_upper <- aft_assign <- rep(0.0, n)\n  var_cov <- aftlm$var[-length(diag(aftlm$var)),-length(diag(aftlm$var))]\n  aft_var <- rep(0.0, n)\n  for(j in 1:n) {\n    aft_var[j] <- sum((var_cov%*%VV[j,])*VV[j,])\n    if(Trt[j]==1) {\n      aft_predict[j] <- aft_hat[j] - aft_hat_alt[j]\n    }\n    else if(Trt[j]==0) {\n      aft_predict[j] <- aft_hat_alt[j] - aft_hat[j]\n    }\n    aft_assign[j] <- ifelse(aft_predict[j] > 0, 1, 0)\n    aft_lower[j] <- aft_predict[j] - qnorm(.975)*sqrt(aft_var[j])\n    aft_upper[j] <- aft_predict[j] + qnorm(.975)*sqrt(aft_var[j])\n  }\n  RMSE_AFT[k] <- sqrt(mean((aft_predict - TrueTheta)^2))\n  Coverage_AFT[k] <- mean((TrueTheta > aft_lower) & (TrueTheta <= aft_upper))\n  MissClass_AFT[k] <- sum(harmful*aft_assign + beneficial*(1 - aft_assign))  ### Number misclassified\n\n  fit_naive <- survreg(form_naive, data=SimDat)\n  if(fit_naive$coefficients[2] > 0) {\n    trt_naive.assign <- rep(1, n)\n  }\n  else if( fit_naive$coefficients[2] <= 0) {\n    trt_naive.assign <- rep(0, n)\n  }\n  #############################################################################\n  #### Non-parametric BART\n  obj <- IndivAFT(x.train=XX,y.train=yy,status=delta,Trt=Trt, ndpost=ndpost,nskip=nskip,printevery=100, sigquant=.5, keepevery=5)\n  post.means <- colMeans(obj$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob <- apply(obj$Theta, 2, function(x) mean( x > 0))\n  treat.assign <- ifelse(post.prob > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci <- apply(obj$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci <- apply(obj$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass[k] <- sum(harmful*treat.assign + beneficial*(1 - treat.assign))  ### Number misclassified\n  RMSE[k] <- sqrt(mean((post.means - TrueTheta)^2))\n  Coverage[k] <- mean((TrueTheta > lower.ci) & (TrueTheta <= upper.ci))\n  obs_frac[k] <- mean(delta)\n  theta.np[k,] <- post.means\n\n  #############################################################################\n  #### Non-parametric BART\n  #Xtmp <- as.matrix(XX[,1:2], nrow=nrow(XX), ncol=2)\n  obj_np <- IndivAFTSeparate(x.train=XX,y.train=yy,status=rep(1,n),Trt=Trt, ndpost=ndpost, nskip=nskip, printevery=100, sigquant=.5, keepevery=5)\n  post.means <- colMeans(obj_np$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob <- apply(obj_np$Theta, 2, function(x) mean( x > 0))\n  treat.assign <- ifelse(post.prob > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci <- apply(obj_np$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci <- apply(obj_np$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass_NPS[k] <- sum(harmful*treat.assign + beneficial*(1 - treat.assign))  ### Number misclassified\n  RMSE_NPS[k] <- sqrt(mean((post.means - TrueTheta)^2))\n  Coverage_NPS[k] <- mean((TrueTheta > lower.ci) & (TrueTheta <= upper.ci))\n  obs_frac_NPS[k] <- mean(delta)\n  theta.nps[k,] <- post.means\n\n  #################################################################################\n  ###  Semi-parametric BART and Naive\n  obj_sp <- IndivAFT(x.train=XX,y.train=yy,status=delta,Trt=Trt, nonparametric=FALSE, ndpost=ndpost,nskip=nskip,printevery=100, sigquant=.9, keepevery=5)\n  overall <- mean(obj$Theta)\n\n  post.means.sp <- colMeans(obj_sp$Theta)\n  ### Get P(\\theta > 0|x) for each individual\n  post.prob.sp <- apply(obj_sp$Theta, 2, function(x) mean( x > 0))\n  treat.assign.sp <- ifelse(post.prob.sp > 1/2, 1, 0) ### assign Trt=1 if post.prob > 1/2\n\n  upper.ci.sp <- apply(obj_sp$Theta, 2, function(x) quantile(x, prob=.975))\n  lower.ci.sp <- apply(obj_sp$Theta, 2, function(x) quantile(x, prob=.025))\n\n  MissClass_SP[k] <- sum(harmful*treat.assign.sp + beneficial*(1 - treat.assign.sp))  ### Number misclassified\n  RMSE_SP[k] <- sqrt(mean((post.means.sp - TrueTheta)^2))\n  Coverage_SP[k] <- mean((TrueTheta > lower.ci.sp) & (TrueTheta <= upper.ci.sp))\n  obs_frac_SP[k] <- mean(delta)\n\n  MissClassNaive[k] <- sum(harmful*trt_naive.assign + beneficial*(1 - trt_naive.assign))\n  print(c(count,k))\n}\n\nResults_NP[count,1] <- mean(RMSE)\nResults_NP[count,2] <- mean(MissClass)/n\nResults_NP[count,3] <- mean(Coverage)\nResults_NP[count,4] <- n\nResults_NP[count,5] <- mean(obs_frac)\nBias <- colMeans(theta.np) - generated_fn$TrueTheta\nvv <- apply(theta.np, 2, var)\nResults_NP[count,6] <- mean(abs(Bias))\nResults_NP[count,7] <- mean(vv)\n\nResults_NPS[count,1] <- mean(RMSE_NPS)\nResults_NPS[count,2] <- mean(MissClass_NPS)/n\nResults_NPS[count,3] <- mean(Coverage_NPS)\nResults_NPS[count,4] <- n\nResults_NPS[count,5] <- mean(obs_frac_NPS)\nBias2 <- colMeans(theta.nps) - generated_fn$TrueTheta\nvv2 <- apply(theta.nps, 2, var)\nResults_NPS[count,6] <- mean(abs(Bias2))\nResults_NPS[count,7] <- mean(vv2)\n\n\nResults_SP[count,1] <- mean(RMSE_SP)\nResults_SP[count,2] <- mean(MissClass_SP)/n\nResults_SP[count,3] <- mean(Coverage_SP)\nResults_SP[count,4] <- n\nResults_SP[count,5] <- mean(obs_frac_SP)\n\n\nResults_AFT[count,1] <- mean(RMSE_AFT)\nResults_AFT[count,2] <- mean(MissClass_AFT)/n\nResults_AFT[count,3] <- mean(Coverage_AFT)\nResults_AFT[count,4] <- n\nResults_AFT[count,5] <- mean(obs_frac)\nResultsNaive[count] <- mean(MissClassNaive)/n\n\n#save(Results_AFT, ResultsNaive, file=\"~/personalized/paper_simulations/friedman/normal_aft_friedman.RData\")\nsave(Results_NP, Results_SP, Results_AFT, ResultsNaive, Results_NPS, file=\"~/personalized/paper_simulations/friedman/normal_friedman22.RData\")\n\n#load(\"~/personalized/paper_simulations/friedman/normal_friedman2.RData\")\n\nA <- matrix(0, nrow=3, ncol=8)\nA[,1] <- rep(n, 3)\nA[,2] <- c(0,1,2)\nA[,3] <- Results_NP[,1]\nA[,4] <- Results_NP[,2]\nA[,5] <- Results_NP[,3]\nA[,6] <- Results_NPS[,1]\nA[,7] <- Results_NPS[,2]\nA[,8] <- Results_NPS[,3]\n\nxtable(A, digits=3)\n\n\n\n\n\n\n\n\n\n",
    "created" : 1523333201477.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1184174651",
    "id" : "A5A5C06E",
    "lastKnownWriteTime" : 1524249097,
    "last_content_update" : 1524249099147,
    "path" : "~/personalized/Reproduce_folders/SimulationCode/friedman/normal.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 37,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}